<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>_proto_&amp;prototype&amp;constructor</title>
<script>
	/* prototype constructor typeof instanceof */
	/* 核心：所有对象都有_proto_属性(隐式原型), 默认指向其构造函数的原型对象(prototype属性), 这就是原型链的本质*/
    /* 定义function时，JavaScript内部自动做了以下操作：
     * （前提：所有function均为Function的实例对象）
     * 1.为该函数添加一个原型（即 prototype）属性，指向prototype对象
     * 2.为prototype 对象额外添加一个 constructor 属性，并且该属性保存指向函数F的一个引用，所以其实例对象也获得了constructor属性
     */
    function Person(id, username, password){
        this.id = id;
        this.username = username;
        this.password = password;
        
        Person.prototype.getPrimaryKey = function() {
            return 'id';
        }
    }
    
    var person = new Person('1','jzz','123');
    person.age = 13;
    console.dir(Person)
    console.log('=======================================================')
    console.log(person)
    console.log('=======================================================')
    console.log(Person.prototype.constructor === person.constructor); //true  每一个对象实例中可以访问构造函数的 prototype 所有拥有的全部属性和方法，就好像它们是实例自己的一样。
    console.log(person.constructor === Person); //true
    console.log(Person.constructor === Function); //true 所有函数都是 Function 构造函数的实例对象
    console.log(person.hasOwnProperty('age'))   //对象自己的属性
    console.log(person.hasOwnProperty('id')) // true  非常不能理解！！！why？？？
    console.log(Person.isPrototypeOf(person)) //false 非常不能理解！！！why？？？
    console.log('=======================================================')
    console.log(Person.prototype.__proto__); //{}  这就到头了？？
    console.log(Person.__proto__ == Function.prototype);  //指向Person的构造函数的原型对象，即Function
    console.log('=======================================================')
    console.log(Person.prototype);
    console.log(person.prototype);  //undefined, 这很好理解，虽说person获了得Person.prototype的全部属性（但person作为对象而不是方法，自身并没有prototype属性，除非自己手动添加）
    
    console.log(Person instanceof Function); // true
    console.log(person instanceof Person); //true
    console.log(typeof(Person));  //'function'  typeof返回的一定是个字符串
    console.log(typeof(person)); //'object' 注意这里，足以显示出typeof的局限性，不能返回具体的类型
    
    
    /* 关于原型链的经典演示！*/
    function a(name){
        this.name = name;
    }
    a.prototype.test = function(){
        console.log(this.name);    
    }
    var b = function (){}
    b.prototype = new a('test');
    
    var t = new b();
    t.test();
    // t._proto_ == b.prototype == new a('test')
    // t._proto_._proto_ == b.prototype._proto_ == new a('test')._proto_ == a.prototype
    // 所以先找t自身即new b()对象是否有test属性，b.prototype即new a('test')对象， 再找a.prototype对象，这就是原型链！
             
    console.log(new b().constructor)  //可以看出使用new新建出来的对象的constructor已经改变了，即new b().constructor = a.prototype.constructor
    console.log(new a().constructor)

</script>
</head>
<body>
</body>
</html>
